<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pyduration.duration API documentation</title>
<meta name="description" content="A calendar unit length utility library …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyduration.duration</code></h1>
</header>
<section id="section-intro">
<p>A calendar unit length utility library.</p>
<p>Start by importing <code><a title="pyduration.duration.Duration" href="#pyduration.duration.Duration">Duration</a></code>:</p>
<pre><code>from pyduration import Duration
</code></pre>
<p>See Duration.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A calendar unit length utility library.

Start by importing `Duration`:

```
from pyduration import Duration
```

See Duration.
&#34;&#34;&#34;

import arrow
import math
import re
import warnings
import typing
from calendar import Calendar
from time import time
from typing import *
from . import util
from intervalpy import Interval
from numbers import Number
from datetime import date, timedelta
from collections.abc import Iterable, Sequence, Mapping

YEARS = &#39;years&#39;
MONTHS = &#39;months&#39;
WEEKS = &#39;weeks&#39;
DAYS = &#39;days&#39;
HOURS = &#39;hours&#39;
MINUTES = &#39;minutes&#39;
SECONDS = &#39;seconds&#39;
MICROSECONDS = &#39;microseconds&#39;


TIME_UNIT_MAP = {
    &#39;y&#39;: YEARS,
    &#39;M&#39;: MONTHS,
    &#39;w&#39;: WEEKS,
    &#39;d&#39;: DAYS,
    &#39;h&#39;: HOURS,
    &#39;m&#39;: MINUTES,
    &#39;s&#39;: SECONDS,
    &#39;S&#39;: MICROSECONDS,
    &#39;μs&#39;: MICROSECONDS
}

TIME_SYMBOL_MAP = {u: s for s, u in TIME_UNIT_MAP.items()}
TIME_SYMBOLS = set(TIME_UNIT_MAP.keys())
TIME_UNITS = set(TIME_UNIT_MAP.values())

TIME_UNITS_PLURAL = TIME_UNITS
SINGLUAR_UNIT_MAP = {u: u[:-1] for u in TIME_UNITS_PLURAL}
TIME_UNITS_SINGLUAR = set(TIME_UNIT_MAP.values())
TIME_UNITS_P_AND_S = TIME_UNITS_PLURAL.union(TIME_UNITS_SINGLUAR)

CHILDREN = {
    YEARS: [
        MONTHS,
        WEEKS,
        DAYS
    ],
    DAYS: [
        HOURS,
        MINUTES,
        SECONDS
    ],
    SECONDS: [
        MICROSECONDS
    ]
}
PARENTS: Dict[str, str] = {}
for parent, children in CHILDREN.items():
    for child in children:
        PARENTS[child] = parent

CALENDAR_UNITS = [
    YEARS,
    MONTHS,
    WEEKS
]

SECONDS_RANGES = {
    YEARS: (365 * 86400.0, 366 * 86400.0),
    MONTHS: (28 * 86400.0, 31 * 86400.0),
    WEEKS: (7 * 86400.0, 7 * 86400.0),
    DAYS: (86400.0, 86400.0),
    HOURS: (3600.0, 3600.0),
    MINUTES: (60.0, 60.0),
    SECONDS: (1.0, 1.0),
    MICROSECONDS: (1e-6, 1e-6)
}

SECONDS_AVE = {
    YEARS: 365.25 * 86400.0,
    MONTHS: 30.436875 * 86400.0,
    WEEKS: 7 * 86400.0,
    DAYS: 86400.0,
    HOURS: 3600.0,
    MINUTES: 60.0,
    SECONDS: 1.0,
    MICROSECONDS: 1e-6
}

_str_parse_cache: Dict[str, &#39;Duration&#39;] = {}

# TIME_SPAN_REGEX = r&#39;\s*(?&lt;quantity&gt;\d+)\s*(?&lt;unit&gt;((d(ays?)?)|(h((ours?)|(rs?))?)|(m((inutes?)|(ins?))?)|(s((econds?)|(ecs?))?)|\Z))+&#39;


class Duration:
    &#34;&#34;&#34;
    Specifies a length of time in calendar unit.
    For example, 1 day, 2 hours, 2 months, 1 week.
    &#34;&#34;&#34;

    class units:
        year = YEARS
        month = MONTHS
        week = WEEKS
        day = DAYS
        hour = HOURS
        minute = MINUTES
        second = SECONDS
        microsecond = MICROSECONDS
        all = TIME_UNITS

    def __init__(self, *args, **kwargs):
        self._data: Dict[str, int] = {}
        self._parent = None
        self._min_seconds = None
        self.calendar = Calendar()
        data = type(self).normalized_dict(*args, **kwargs)
        self.set_descriptor(data)

    def __repr__(self):
        try:
            return self.to_str()
        except Exception as e:
            return super().__repr__() + f&#39;({e})&#39;

    def __eq__(self, other):
        return self.equals(other)

    def __hash__(self):
        return hash(&#39;,&#39;.join([f&#39;{k}:{v}&#39; for k, v in self._data.items()]))

    def equals(self, other):
        return type(self) == type(other) and \
            self._data == other._data

    @classmethod
    def parse(cls, *args, **kwargs):
        cached = cls._get_cache(*args, **kwargs)
        if cached is not None:
            return cached

        if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], Duration):
            return args[0]
        else:
            r = Duration(*args, **kwargs)
            cls._set_cache(r, *args, **kwargs)
            return r

    @classmethod
    def parse_many(cls, a):
        return [cls.parse(x) for x in a]

    @property
    def degree(self):
        return list(self._data.values())[0]

    @property
    def symbol(self):
        return type(self).unit_symbol(self.unit)

    @property
    def unit(self):
        return list(self._data.keys())[0]

    @property
    def is_calendar_required(self):
        if self.unit in CALENDAR_UNITS:
            return True
        # If we are not uniformly spread out
        # in a parent interval which, requires
        # a calendar, then we also require a
        # calendar to be able to find the
        # correct strating date.
        return self.parent is not None and \
            self.parent.is_calendar_required and \
            not self.is_uniform

    @property
    def is_uniform(self):
        if self._is_uniform_special_case():
            return True
        if self.min_seconds != self.max_seconds:
            return False
        if self.parent is None:
            return True
        coef = self._seconds_coef()
        s = self.ave_seconds * coef
        min_s = self.parent.min_seconds * coef
        max_s = self.parent.max_seconds * coef
        return min_s % s == 0 and max_s % s == 0

    @property
    def parent(self):
        &#34;&#34;&#34;
        Returns the parent calendar length, which clamps
        this calendar length&#39;s intervals its intervals.
        &#34;&#34;&#34;
        if self._parent is None:
            if self.unit not in PARENTS:
                return None
            parent_unit = PARENTS[self.unit]
            self._parent = Duration({parent_unit: 1})
        return self._parent

    @property
    def total_seconds(self):
        if not self.is_uniform:
            raise Exception(f&#39;Cannot convert calendar length {self} to uniform seconds&#39;)
        return self.min_seconds

    @property
    def ave_seconds(self):
        return self.degree * SECONDS_AVE[self.unit]

    @property
    def min_seconds(self):
        if self._min_seconds is None:
            s = self.degree * SECONDS_RANGES[self.unit][0]
            if self.parent is None or self.degree == 1 or self._is_uniform_special_case():
                return s
            # The last interval may be smaller
            coef = self._seconds_coef()
            s *= coef
            parent_s = self.parent.min_seconds * coef
            last_s = parent_s % s
            if last_s == 0:
                # Uniform interval
                last_s = s
            self._min_seconds = last_s / coef
        return self._min_seconds

    @property
    def max_seconds(self):
        return self.degree * SECONDS_RANGES[self.unit][1]

    def to_str(self):
        return f&#39;{self.degree}{self.symbol}&#39;

    def set_descriptor(self, data):
        ndata = type(self).normalized_dict(data)
        if ndata is None:
            raise Exception(f&#39;Invalid calendar length data: {data}&#39;)
        self._data = ndata

    def get_descriptor(self):
        return dict(self._data)

    def aggregate(self, degree: int) -&gt; &#39;Duration&#39;:
        &#34;&#34;&#34;
        Returns a calendar length multiplied by the specified `degree`.
        &#34;&#34;&#34;
        return self.with_degree(self.degree * degree)

    def with_degree(self, degree: int) -&gt; &#39;Duration&#39;:
        &#34;&#34;&#34;
        Returns a calendar length with specified `degree`.
        &#34;&#34;&#34;
        assert degree &gt; 0
        if degree == self.degree:
            return self
        d = self.get_descriptor()
        d = {k: degree for k, v in d.items()}
        return Duration(d)

    def iterate(self, interval, size=1, backward=False, start_open=False) -&gt; Iterator[Optional[Interval]]:
        &#34;&#34;&#34;
        Iterates time-spans inside a interval.
        Does not trim timespans inside the interval.
        &#34;&#34;&#34;
        interval = Interval.parse(interval, default_inf=True)
        if interval.is_empty:
            return iter([])
        start = interval.start if not backward else interval.end
        if math.isinf(start):
            raise ValueError(&#39;Cannot iterate intervals from infinity&#39;)
        if size &lt; 1:
            raise ValueError(&#39;Size must ba a positive integer&#39;)

        if self.is_uniform:
            interval_span = self.span_interval(interval, start_open=start_open)
            start = interval_span.start if not backward else interval_span.end
            count = math.ceil(self.count(interval_span, start_open=start_open) / size)
            step = size * self.ave_seconds
            if backward:
                step = -step
            i = 0

            def next_uniform_span():
                nonlocal start, step, i, count

                if i == count:
                    return None
                a = start + i * step
                b = a + step
                i += 1
                return Interval(min(a, b), max(a, b), start_open=start_open, end_open=not start_open)

            return iter(next_uniform_span, None)

        walker = self.walk(start, size=size, backward=backward, start_open=start_open)

        def next_span_in_interval():
            nonlocal start

            while True:
                span = next(walker)
                if span is None or span.is_empty:
                    return None
                elif span.intersects(interval):
                    return span
                elif span.contains(start):
                    # Keep looking for interval
                    continue
                else:
                    # Went outside interval
                    return None

            return None

        return iter(next_span_in_interval, None)

    def walk(
        self,
        start,
        limit: Optional[Number] = None,
        size=1,
        backward=False,
        start_open=False
    ) -&gt; Iterator[Optional[Interval]]:
        &#34;&#34;&#34;
        Iterates time-spans.
        &#34;&#34;&#34;
        if limit is not None:
            if limit == 0:
                return iter([])
            if limit &lt; 0:
                limit = -limit
                backward = not backward
        span = self.span_date(start, start_open=start_open)
        if backward:
            x1 = span.end
        else:
            x1 = span.start
        count = 0

        def next_span():
            nonlocal x1, count
            if limit is not None and count &gt;= limit:
                return None
            count += 1
            x0 = x1
            x1 = self.step(x0, count=size, backward=backward)
            span = Interval(min(x0, x1), max(x0, x1), start_open=start_open, end_open=not start_open)
            return span

        return iter(next_span, None)

    def round(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the closest boundary to the specified `date`.
        &#34;&#34;&#34;
        ceil = self.ceil(date)
        floor = self.floor(date)
        if ceil - date &lt;= date - floor:
            return ceil
        else:
            return floor

    def floor(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the boundary at or before the specified `date`.
        &#34;&#34;&#34;
        return self.span_date(date, start_open=False).start

    def ceil(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the boundary at or after the specified `date`.
        &#34;&#34;&#34;
        return self.span_date(date, start_open=True).end

    def next(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the next boundary after the specified `date`.
        &#34;&#34;&#34;
        return self.span_date(date, start_open=False).end

    def previous(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the previous boundary before the specified `date`.
        &#34;&#34;&#34;
        return self.span_date(date, start_open=True).start

    def step(self, date, count=1, backward=False) -&gt; float:
        &#34;&#34;&#34;
        Returns the `count`th boundary after or before the specified `date`.
        &#34;&#34;&#34;
        date = self._normalized_date(date)
        if count == 0:
            return date
        if count &lt; 0:
            backward = not backward
            count = -count
        count = int(count)
        rounder = self.ceil if not backward else self.floor
        ndate = rounder(date)
        if ndate != date:
            count -= 1

        if count &gt; 1 and self.is_uniform:
            # Use seconds
            if backward:
                count = -count
            seconds = self.ave_seconds
            return ndate + seconds * count
        else:
            # Iterate
            step = self.next if not backward else self.previous
            for _ in range(count):
                ndate = step(ndate)
            return ndate

    def pad(self, interval, start=0, end=0, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Appends calendar lengths to the start and end of a interval.
        &#34;&#34;&#34;
        interval = self.span_interval(interval, start_open=start_open)
        if interval.is_empty:
            return Interval.empty()

        l = interval.start
        if not interval.is_negative_infinite:
            l = self.step(l, count=start, backward=True)

        h = interval.end
        if not interval.is_positive_infinite:
            h = self.step(h, count=end)

        return Interval(l, h, start_open=start_open, end_open=not start_open)

    def span(self, x, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Returns the time interval which contains the specified single date or interval.
        &#34;&#34;&#34;
        if isinstance(x, Number):
            return self.span_date(x, start_open=start_open)
        else:
            return self.span_interval(x, start_open=start_open)

    def span_date(self, date, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Returns the time interval which contains the specified `date`.
        &#34;&#34;&#34;
        if self.is_calendar_required:
            return self._calendar_span(date, start_open=start_open)
        else:
            return self._non_calendar_span(date, start_open=start_open)

    def _non_calendar_span(self, date, start_open=False) -&gt; Interval:
        # We can use seconds
        coef = self._seconds_coef()
        t = self._normalized_date(date) * coef

        if self.degree == 1:
            # Do not limit to parent for speed
            parent_start = 0
            parent_secs = math.inf
        else:
            # Start from parent start
            parent_span = self.parent.span_date(date, start_open=start_open)
            parent_start = parent_span.start * coef
            parent_secs = parent_span.length * coef

        seconds = self.ave_seconds * coef
        parent_t = t - parent_start
        start = math.floor(parent_t / seconds) * seconds
        end = math.ceil(parent_t / seconds) * seconds

        if start == end:
            if start_open:
                start -= seconds
            else:
                end += seconds

        # Limit to parent end
        if end &gt; parent_secs:
            end = parent_secs

        start_date = parent_start + start
        end_date = parent_start + end

        start_date /= coef
        end_date /= coef

        return Interval(
            start_date,
            end_date,
            start_open=start_open,
            end_open=not start_open
        )

    def _calendar_span(self, date, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Returns the time interval which contains the specified `date`.
        &#34;&#34;&#34;
        date = arrow.get(date)
        t = self._normalized_date(date)
        msec = timedelta(microseconds=1)
        start = date - msec
        end = date + msec
        degree = self.degree
        unit = self.unit
        sunit = type(self).singular_unit(unit)
        date_span = None

        force_agr = unit == WEEKS
        if force_agr:
            # Special case
            sunit = type(self).singular_unit(DAYS)

        # Find matching unit interval (1d, 1h, etc)
        for r0, r1 in arrow.Arrow.span_range(sunit, start, end):
            # Normalize range end
            r1 += msec
            interval = Interval(r0.float_timestamp, r1.float_timestamp, start_open=start_open, end_open=not start_open)
            if interval.contains(t):
                if degree == 1 and not force_agr:
                    return interval
                else:
                    date_span = r0, r1
                    break

        # Expand into aggregate interval
        if self.unit == YEARS:
            start_date, end_date = self._expand_years(date_span)
        elif self.parent is not None and self.parent.unit == YEARS:
            start_date, end_date = self._expand_within_year(date_span)
        else:
            raise Exception(f&#39;Unable to expand unit: {self.unit}&#39;)

        return Interval(
            self._normalized_date(start_date),
            self._normalized_date(end_date),
            start_open=start_open,
            end_open=not start_open
        )

    def _expand_years(self, date_span):
        start_date = date_span[0]
        end_date = date_span[1]

        start_date = start_date.floor(&#39;year&#39;)
        end_date = start_date.shift(years=self.degree)

        assert end_date &gt; start_date
        return start_date, end_date

    def _expand_within_year(self, date_span):
        start_date = date_span[0]
        end_date = date_span[1]
        degree = self.degree
        unit = self.unit

        if unit == WEEKS:
            # Limit to the 1st day of the first week
            year_start = self.calendar.monthdatescalendar(start_date.year, 1)[0][0]
            year_end = self.calendar.monthdatescalendar(start_date.year + 1, 1)[0][0]
            year_start = arrow.get(year_start)
            year_end = arrow.get(year_end)
        else:
            # Limit to the 1st January
            year_start = start_date.floor(&#39;year&#39;)
            year_end = start_date.ceil(&#39;year&#39;) + timedelta(microseconds=1)

        if end_date &gt; year_end:
            end_date = year_end

        if unit == DAYS or unit == WEEKS:
            day_res = degree
            if unit == WEEKS:
                day_res *= 7
            
            start = (start_date - year_start).days
            start = math.floor(start / day_res) * day_res
            start_date = year_start + timedelta(days=start)

            end = (end_date - year_start).days
            end = math.ceil(end / day_res) * day_res
            end_date = year_start + timedelta(days=end)
        elif unit == MONTHS:
            start = start_date.month - 1
            start = math.floor(start / degree) * degree
            start_date = arrow.get(start_date.year, start + 1, 1)

            end = end_date.month - 1
            end = math.ceil(end / degree) * degree
            end_date = arrow.get(end_date.year, end + 1, 1)
        else:
            raise Exception(f&#39;Unit not supported: {unit}&#39;)

        if end_date &gt; year_end:
            end_date = year_end

        assert end_date &gt; start_date
        return start_date, end_date

    def span_interval(self, interval, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Returns the time interval which fully contains the specified interval.
        &#34;&#34;&#34;
        interval = Interval.parse(interval, default_inf=True)
        if interval.is_empty:
            return Interval.empty()
        elif interval.start == interval.end:
            return self.span_date(interval.start, start_open=start_open)

        end_open = not start_open

        if interval.is_negative_infinite:
            start = -math.inf
        else:
            # Move outward if interval is closed but should be open
            o = not interval.start_open and start_open
            span = self.span_date(interval.start, start_open=o)
            start = span.start

        if interval.is_positive_infinite:
            end = math.inf
        else:
            # Move outward if interval is closed but should be open
            o = not interval.end_open and end_open
            span = self.span_date(interval.end, start_open=not o)
            end = span.end

        return Interval(start, end, start_open=start_open, end_open=not start_open)

    def count(self, interval, start_open=False) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of intervals in the specified interval.
        &#34;&#34;&#34;
        interval = Interval.parse(interval, default_inf=True)
        if interval.is_empty:
            return 0
        if not interval.is_finite:
            raise Exception(&#39;Cannot count intervals on infinite interval&#39;)
        interval = self.span_interval(interval, start_open=start_open)

        if not self.is_uniform:
            # Walk spans
            # TODO: this can be optimised to avoid walking
            count = 0
            for _ in self.iterate(interval):
                count += 1
            return count
        else:
            # Use seconds
            return int(math.ceil(interval.length / self.ave_seconds))

    def _is_uniform_special_case(self):
        if self.unit == WEEKS and self.degree == 1:
            return True
        return False

    def _seconds_coef(self):
        &#34;&#34;&#34;
        Apply this coefficient when comparing seconds
        to minimise floating point errors.
        &#34;&#34;&#34;
        s = self.ave_seconds
        assert s &gt; 0
        if s &gt;= 1:
            return 1
        return 10 ** -round(math.log(s, 10))

    def _normalized_date(self, date):
        return util.timestamp(date)

    @classmethod
    def normalized_dict(cls, *args, **kwargs) -&gt; Optional[Dict[str, int]]:
        args = util.flatten(args)
        split_args: List[Any] = []
        for arg in args:
            if isinstance(arg, str):
                split_args += arg.split(&#39; &#39;)
            else:
                split_args.append(arg)
        split_args.append(dict(kwargs))
        split_args = list(filter(None, split_args))
        args = split_args

        if len(args) == 1 and isinstance(args[0], Number):
            # Single number argument is assumed to be in seconds.
            seconds = args[0]
            if seconds &lt; 0:
                return None
            args[0] = timedelta(seconds=seconds)

        t: Dict[str, int] = {}

        for i in range(len(args)):
            arg = args[i]
            is_str = isinstance(arg, (str, bytes))
            if isinstance(arg, Duration):
                arg = arg.get_descriptor()

            if isinstance(arg, timedelta):
                # Normalize the time components as
                # much as possible.
                date = arrow.get(arg.seconds, tzinfo=&#39;utc&#39;)
                arg = {
                    DAYS: arg.days,
                    HOURS: date.hour,
                    MINUTES: date.minute,
                    SECONDS: date.second,
                    MICROSECONDS: arg.microseconds
                }

            if is_str:
                values = re.findall(r&#39;\d+&#39;, arg)
                units = re.findall(r&#39;\D+&#39;, arg)
                if len(values) &gt; 1:
                    return None
                elif len(units) &gt; 1:
                    return None
                if len(values) == 1 and len(units) == 1:
                    arg = [values[0], units[0]]
                    is_str = False

            if is_str or not isinstance(arg, Iterable):
                if i == 0:
                    continue
                arg = [args[i - 1], args[i]]
                is_str = False

            if not is_str and isinstance(arg, Sequence):
                try:
                    val = float(arg[0])
                    unit = str(arg[1])
                    arg = {unit: val}
                except Exception:
                    continue

            if isinstance(arg, Mapping):
                for maybe_unit in arg:
                    unit = cls.parse_unit(maybe_unit)
                    if unit is None:
                        # Invalid unit
                        return None
                    if unit in t:
                        # Repeated values for one unit is dissalowed
                        return None
                    val = arg[maybe_unit]
                    if not isinstance(val, Number) or val &lt; 0:
                        # Only positive values supported
                        return None
                    t[unit] = int(val)

        t = util.filter_any(None, t)

        if len(t) != 1:
            # A calendar length can be only be made up of one component
            return None

        return t

    @classmethod
    def parse_unit(cls, maybe_unit):
        unit = None
        if maybe_unit in TIME_SYMBOLS:
            unit = TIME_UNIT_MAP[maybe_unit]
        else:
            maybe_unit = maybe_unit.lower()
            for valid_unit in TIME_UNITS_P_AND_S:
                if valid_unit.startswith(maybe_unit):
                    unit = valid_unit
                    break
            if unit not in TIME_UNITS:
                # Invalid unit
                unit = None
        return unit

    @classmethod
    def unit_symbol(cls, unit):
        assert unit in TIME_UNITS
        return TIME_SYMBOL_MAP[unit]

    @classmethod
    def singular_unit(cls, unit):
        assert unit in TIME_UNITS
        return SINGLUAR_UNIT_MAP[unit]

    @classmethod
    def plural_unit(cls, unit):
        assert unit in TIME_UNITS
        return unit

    @classmethod
    def _seconds_arithmetic(cls, a):
        # Check for numbers
        for x in a:
            if isinstance(x, Number):
                return True

    @classmethod
    def _to_seconds(cls, a):
        seconds: List[float] = []
        for x in a:
            if isinstance(x, Duration):
                seconds.append(x.total_seconds)
                warnings.warn(&#39;Implicitly converting calendar length into seconds&#39;, UserWarning)
            else:
                seconds.append(float(x))
        return seconds

    @classmethod
    def _get_cache(cls, *args, **kwargs):
        if len(args) == 1 and len(kwargs) == 0 and type(args[0]) == str:
            if args[0] in _str_parse_cache:
                return _str_parse_cache[args[0]]
        return None

    @classmethod
    def _set_cache(cls, r, *args, **kwargs):
        if len(args) == 1 and len(kwargs) == 0 and type(args[0]) == str:
            _str_parse_cache[args[0]] = r

    def __add__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] + secs[1]

    def __sub__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] - secs[1]

    def __mul__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] * secs[1]

    def __truediv__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] / secs[1]

    def __floordiv__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] // secs[1]

    def __radd__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] + secs[1]

    def __rsub__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] - secs[1]

    def __rmul__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] * secs[1]

    def __rtruediv__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] / secs[1]

    def __rfloordiv__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] // secs[1]

    def __neg__(self):
        return -self.total_seconds

    def __pos__(self):
        return self.total_seconds

    def __abs__(self):
        return self.total_seconds

    def __lt__(self, other):
        if isinstance(other, Number):
            return self.max_seconds &lt; other

        if type(self) != type(other):
            raise Exception(f&#39;Unable to compare with: {other}&#39;)
        if self.unit == other.unit:
            return self.degree &lt; other.degree
        else:
            return self.max_seconds &lt; other.min_seconds

    def __gt__(self, other):
        if isinstance(other, Number):
            return self.min_seconds &gt; other

        if type(self) != type(other):
            raise Exception(f&#39;Unable to compare with: {other}&#39;)
        if self.unit == other.unit:
            return self.degree &gt; other.degree
        else:
            return self.min_seconds &gt; other.max_seconds</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyduration.duration.Duration"><code class="flex name class">
<span>class <span class="ident">Duration</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Specifies a length of time in calendar unit.
For example, 1 day, 2 hours, 2 months, 1 week.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Duration:
    &#34;&#34;&#34;
    Specifies a length of time in calendar unit.
    For example, 1 day, 2 hours, 2 months, 1 week.
    &#34;&#34;&#34;

    class units:
        year = YEARS
        month = MONTHS
        week = WEEKS
        day = DAYS
        hour = HOURS
        minute = MINUTES
        second = SECONDS
        microsecond = MICROSECONDS
        all = TIME_UNITS

    def __init__(self, *args, **kwargs):
        self._data: Dict[str, int] = {}
        self._parent = None
        self._min_seconds = None
        self.calendar = Calendar()
        data = type(self).normalized_dict(*args, **kwargs)
        self.set_descriptor(data)

    def __repr__(self):
        try:
            return self.to_str()
        except Exception as e:
            return super().__repr__() + f&#39;({e})&#39;

    def __eq__(self, other):
        return self.equals(other)

    def __hash__(self):
        return hash(&#39;,&#39;.join([f&#39;{k}:{v}&#39; for k, v in self._data.items()]))

    def equals(self, other):
        return type(self) == type(other) and \
            self._data == other._data

    @classmethod
    def parse(cls, *args, **kwargs):
        cached = cls._get_cache(*args, **kwargs)
        if cached is not None:
            return cached

        if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], Duration):
            return args[0]
        else:
            r = Duration(*args, **kwargs)
            cls._set_cache(r, *args, **kwargs)
            return r

    @classmethod
    def parse_many(cls, a):
        return [cls.parse(x) for x in a]

    @property
    def degree(self):
        return list(self._data.values())[0]

    @property
    def symbol(self):
        return type(self).unit_symbol(self.unit)

    @property
    def unit(self):
        return list(self._data.keys())[0]

    @property
    def is_calendar_required(self):
        if self.unit in CALENDAR_UNITS:
            return True
        # If we are not uniformly spread out
        # in a parent interval which, requires
        # a calendar, then we also require a
        # calendar to be able to find the
        # correct strating date.
        return self.parent is not None and \
            self.parent.is_calendar_required and \
            not self.is_uniform

    @property
    def is_uniform(self):
        if self._is_uniform_special_case():
            return True
        if self.min_seconds != self.max_seconds:
            return False
        if self.parent is None:
            return True
        coef = self._seconds_coef()
        s = self.ave_seconds * coef
        min_s = self.parent.min_seconds * coef
        max_s = self.parent.max_seconds * coef
        return min_s % s == 0 and max_s % s == 0

    @property
    def parent(self):
        &#34;&#34;&#34;
        Returns the parent calendar length, which clamps
        this calendar length&#39;s intervals its intervals.
        &#34;&#34;&#34;
        if self._parent is None:
            if self.unit not in PARENTS:
                return None
            parent_unit = PARENTS[self.unit]
            self._parent = Duration({parent_unit: 1})
        return self._parent

    @property
    def total_seconds(self):
        if not self.is_uniform:
            raise Exception(f&#39;Cannot convert calendar length {self} to uniform seconds&#39;)
        return self.min_seconds

    @property
    def ave_seconds(self):
        return self.degree * SECONDS_AVE[self.unit]

    @property
    def min_seconds(self):
        if self._min_seconds is None:
            s = self.degree * SECONDS_RANGES[self.unit][0]
            if self.parent is None or self.degree == 1 or self._is_uniform_special_case():
                return s
            # The last interval may be smaller
            coef = self._seconds_coef()
            s *= coef
            parent_s = self.parent.min_seconds * coef
            last_s = parent_s % s
            if last_s == 0:
                # Uniform interval
                last_s = s
            self._min_seconds = last_s / coef
        return self._min_seconds

    @property
    def max_seconds(self):
        return self.degree * SECONDS_RANGES[self.unit][1]

    def to_str(self):
        return f&#39;{self.degree}{self.symbol}&#39;

    def set_descriptor(self, data):
        ndata = type(self).normalized_dict(data)
        if ndata is None:
            raise Exception(f&#39;Invalid calendar length data: {data}&#39;)
        self._data = ndata

    def get_descriptor(self):
        return dict(self._data)

    def aggregate(self, degree: int) -&gt; &#39;Duration&#39;:
        &#34;&#34;&#34;
        Returns a calendar length multiplied by the specified `degree`.
        &#34;&#34;&#34;
        return self.with_degree(self.degree * degree)

    def with_degree(self, degree: int) -&gt; &#39;Duration&#39;:
        &#34;&#34;&#34;
        Returns a calendar length with specified `degree`.
        &#34;&#34;&#34;
        assert degree &gt; 0
        if degree == self.degree:
            return self
        d = self.get_descriptor()
        d = {k: degree for k, v in d.items()}
        return Duration(d)

    def iterate(self, interval, size=1, backward=False, start_open=False) -&gt; Iterator[Optional[Interval]]:
        &#34;&#34;&#34;
        Iterates time-spans inside a interval.
        Does not trim timespans inside the interval.
        &#34;&#34;&#34;
        interval = Interval.parse(interval, default_inf=True)
        if interval.is_empty:
            return iter([])
        start = interval.start if not backward else interval.end
        if math.isinf(start):
            raise ValueError(&#39;Cannot iterate intervals from infinity&#39;)
        if size &lt; 1:
            raise ValueError(&#39;Size must ba a positive integer&#39;)

        if self.is_uniform:
            interval_span = self.span_interval(interval, start_open=start_open)
            start = interval_span.start if not backward else interval_span.end
            count = math.ceil(self.count(interval_span, start_open=start_open) / size)
            step = size * self.ave_seconds
            if backward:
                step = -step
            i = 0

            def next_uniform_span():
                nonlocal start, step, i, count

                if i == count:
                    return None
                a = start + i * step
                b = a + step
                i += 1
                return Interval(min(a, b), max(a, b), start_open=start_open, end_open=not start_open)

            return iter(next_uniform_span, None)

        walker = self.walk(start, size=size, backward=backward, start_open=start_open)

        def next_span_in_interval():
            nonlocal start

            while True:
                span = next(walker)
                if span is None or span.is_empty:
                    return None
                elif span.intersects(interval):
                    return span
                elif span.contains(start):
                    # Keep looking for interval
                    continue
                else:
                    # Went outside interval
                    return None

            return None

        return iter(next_span_in_interval, None)

    def walk(
        self,
        start,
        limit: Optional[Number] = None,
        size=1,
        backward=False,
        start_open=False
    ) -&gt; Iterator[Optional[Interval]]:
        &#34;&#34;&#34;
        Iterates time-spans.
        &#34;&#34;&#34;
        if limit is not None:
            if limit == 0:
                return iter([])
            if limit &lt; 0:
                limit = -limit
                backward = not backward
        span = self.span_date(start, start_open=start_open)
        if backward:
            x1 = span.end
        else:
            x1 = span.start
        count = 0

        def next_span():
            nonlocal x1, count
            if limit is not None and count &gt;= limit:
                return None
            count += 1
            x0 = x1
            x1 = self.step(x0, count=size, backward=backward)
            span = Interval(min(x0, x1), max(x0, x1), start_open=start_open, end_open=not start_open)
            return span

        return iter(next_span, None)

    def round(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the closest boundary to the specified `date`.
        &#34;&#34;&#34;
        ceil = self.ceil(date)
        floor = self.floor(date)
        if ceil - date &lt;= date - floor:
            return ceil
        else:
            return floor

    def floor(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the boundary at or before the specified `date`.
        &#34;&#34;&#34;
        return self.span_date(date, start_open=False).start

    def ceil(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the boundary at or after the specified `date`.
        &#34;&#34;&#34;
        return self.span_date(date, start_open=True).end

    def next(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the next boundary after the specified `date`.
        &#34;&#34;&#34;
        return self.span_date(date, start_open=False).end

    def previous(self, date) -&gt; float:
        &#34;&#34;&#34;
        Returns the previous boundary before the specified `date`.
        &#34;&#34;&#34;
        return self.span_date(date, start_open=True).start

    def step(self, date, count=1, backward=False) -&gt; float:
        &#34;&#34;&#34;
        Returns the `count`th boundary after or before the specified `date`.
        &#34;&#34;&#34;
        date = self._normalized_date(date)
        if count == 0:
            return date
        if count &lt; 0:
            backward = not backward
            count = -count
        count = int(count)
        rounder = self.ceil if not backward else self.floor
        ndate = rounder(date)
        if ndate != date:
            count -= 1

        if count &gt; 1 and self.is_uniform:
            # Use seconds
            if backward:
                count = -count
            seconds = self.ave_seconds
            return ndate + seconds * count
        else:
            # Iterate
            step = self.next if not backward else self.previous
            for _ in range(count):
                ndate = step(ndate)
            return ndate

    def pad(self, interval, start=0, end=0, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Appends calendar lengths to the start and end of a interval.
        &#34;&#34;&#34;
        interval = self.span_interval(interval, start_open=start_open)
        if interval.is_empty:
            return Interval.empty()

        l = interval.start
        if not interval.is_negative_infinite:
            l = self.step(l, count=start, backward=True)

        h = interval.end
        if not interval.is_positive_infinite:
            h = self.step(h, count=end)

        return Interval(l, h, start_open=start_open, end_open=not start_open)

    def span(self, x, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Returns the time interval which contains the specified single date or interval.
        &#34;&#34;&#34;
        if isinstance(x, Number):
            return self.span_date(x, start_open=start_open)
        else:
            return self.span_interval(x, start_open=start_open)

    def span_date(self, date, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Returns the time interval which contains the specified `date`.
        &#34;&#34;&#34;
        if self.is_calendar_required:
            return self._calendar_span(date, start_open=start_open)
        else:
            return self._non_calendar_span(date, start_open=start_open)

    def _non_calendar_span(self, date, start_open=False) -&gt; Interval:
        # We can use seconds
        coef = self._seconds_coef()
        t = self._normalized_date(date) * coef

        if self.degree == 1:
            # Do not limit to parent for speed
            parent_start = 0
            parent_secs = math.inf
        else:
            # Start from parent start
            parent_span = self.parent.span_date(date, start_open=start_open)
            parent_start = parent_span.start * coef
            parent_secs = parent_span.length * coef

        seconds = self.ave_seconds * coef
        parent_t = t - parent_start
        start = math.floor(parent_t / seconds) * seconds
        end = math.ceil(parent_t / seconds) * seconds

        if start == end:
            if start_open:
                start -= seconds
            else:
                end += seconds

        # Limit to parent end
        if end &gt; parent_secs:
            end = parent_secs

        start_date = parent_start + start
        end_date = parent_start + end

        start_date /= coef
        end_date /= coef

        return Interval(
            start_date,
            end_date,
            start_open=start_open,
            end_open=not start_open
        )

    def _calendar_span(self, date, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Returns the time interval which contains the specified `date`.
        &#34;&#34;&#34;
        date = arrow.get(date)
        t = self._normalized_date(date)
        msec = timedelta(microseconds=1)
        start = date - msec
        end = date + msec
        degree = self.degree
        unit = self.unit
        sunit = type(self).singular_unit(unit)
        date_span = None

        force_agr = unit == WEEKS
        if force_agr:
            # Special case
            sunit = type(self).singular_unit(DAYS)

        # Find matching unit interval (1d, 1h, etc)
        for r0, r1 in arrow.Arrow.span_range(sunit, start, end):
            # Normalize range end
            r1 += msec
            interval = Interval(r0.float_timestamp, r1.float_timestamp, start_open=start_open, end_open=not start_open)
            if interval.contains(t):
                if degree == 1 and not force_agr:
                    return interval
                else:
                    date_span = r0, r1
                    break

        # Expand into aggregate interval
        if self.unit == YEARS:
            start_date, end_date = self._expand_years(date_span)
        elif self.parent is not None and self.parent.unit == YEARS:
            start_date, end_date = self._expand_within_year(date_span)
        else:
            raise Exception(f&#39;Unable to expand unit: {self.unit}&#39;)

        return Interval(
            self._normalized_date(start_date),
            self._normalized_date(end_date),
            start_open=start_open,
            end_open=not start_open
        )

    def _expand_years(self, date_span):
        start_date = date_span[0]
        end_date = date_span[1]

        start_date = start_date.floor(&#39;year&#39;)
        end_date = start_date.shift(years=self.degree)

        assert end_date &gt; start_date
        return start_date, end_date

    def _expand_within_year(self, date_span):
        start_date = date_span[0]
        end_date = date_span[1]
        degree = self.degree
        unit = self.unit

        if unit == WEEKS:
            # Limit to the 1st day of the first week
            year_start = self.calendar.monthdatescalendar(start_date.year, 1)[0][0]
            year_end = self.calendar.monthdatescalendar(start_date.year + 1, 1)[0][0]
            year_start = arrow.get(year_start)
            year_end = arrow.get(year_end)
        else:
            # Limit to the 1st January
            year_start = start_date.floor(&#39;year&#39;)
            year_end = start_date.ceil(&#39;year&#39;) + timedelta(microseconds=1)

        if end_date &gt; year_end:
            end_date = year_end

        if unit == DAYS or unit == WEEKS:
            day_res = degree
            if unit == WEEKS:
                day_res *= 7
            
            start = (start_date - year_start).days
            start = math.floor(start / day_res) * day_res
            start_date = year_start + timedelta(days=start)

            end = (end_date - year_start).days
            end = math.ceil(end / day_res) * day_res
            end_date = year_start + timedelta(days=end)
        elif unit == MONTHS:
            start = start_date.month - 1
            start = math.floor(start / degree) * degree
            start_date = arrow.get(start_date.year, start + 1, 1)

            end = end_date.month - 1
            end = math.ceil(end / degree) * degree
            end_date = arrow.get(end_date.year, end + 1, 1)
        else:
            raise Exception(f&#39;Unit not supported: {unit}&#39;)

        if end_date &gt; year_end:
            end_date = year_end

        assert end_date &gt; start_date
        return start_date, end_date

    def span_interval(self, interval, start_open=False) -&gt; Interval:
        &#34;&#34;&#34;
        Returns the time interval which fully contains the specified interval.
        &#34;&#34;&#34;
        interval = Interval.parse(interval, default_inf=True)
        if interval.is_empty:
            return Interval.empty()
        elif interval.start == interval.end:
            return self.span_date(interval.start, start_open=start_open)

        end_open = not start_open

        if interval.is_negative_infinite:
            start = -math.inf
        else:
            # Move outward if interval is closed but should be open
            o = not interval.start_open and start_open
            span = self.span_date(interval.start, start_open=o)
            start = span.start

        if interval.is_positive_infinite:
            end = math.inf
        else:
            # Move outward if interval is closed but should be open
            o = not interval.end_open and end_open
            span = self.span_date(interval.end, start_open=not o)
            end = span.end

        return Interval(start, end, start_open=start_open, end_open=not start_open)

    def count(self, interval, start_open=False) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of intervals in the specified interval.
        &#34;&#34;&#34;
        interval = Interval.parse(interval, default_inf=True)
        if interval.is_empty:
            return 0
        if not interval.is_finite:
            raise Exception(&#39;Cannot count intervals on infinite interval&#39;)
        interval = self.span_interval(interval, start_open=start_open)

        if not self.is_uniform:
            # Walk spans
            # TODO: this can be optimised to avoid walking
            count = 0
            for _ in self.iterate(interval):
                count += 1
            return count
        else:
            # Use seconds
            return int(math.ceil(interval.length / self.ave_seconds))

    def _is_uniform_special_case(self):
        if self.unit == WEEKS and self.degree == 1:
            return True
        return False

    def _seconds_coef(self):
        &#34;&#34;&#34;
        Apply this coefficient when comparing seconds
        to minimise floating point errors.
        &#34;&#34;&#34;
        s = self.ave_seconds
        assert s &gt; 0
        if s &gt;= 1:
            return 1
        return 10 ** -round(math.log(s, 10))

    def _normalized_date(self, date):
        return util.timestamp(date)

    @classmethod
    def normalized_dict(cls, *args, **kwargs) -&gt; Optional[Dict[str, int]]:
        args = util.flatten(args)
        split_args: List[Any] = []
        for arg in args:
            if isinstance(arg, str):
                split_args += arg.split(&#39; &#39;)
            else:
                split_args.append(arg)
        split_args.append(dict(kwargs))
        split_args = list(filter(None, split_args))
        args = split_args

        if len(args) == 1 and isinstance(args[0], Number):
            # Single number argument is assumed to be in seconds.
            seconds = args[0]
            if seconds &lt; 0:
                return None
            args[0] = timedelta(seconds=seconds)

        t: Dict[str, int] = {}

        for i in range(len(args)):
            arg = args[i]
            is_str = isinstance(arg, (str, bytes))
            if isinstance(arg, Duration):
                arg = arg.get_descriptor()

            if isinstance(arg, timedelta):
                # Normalize the time components as
                # much as possible.
                date = arrow.get(arg.seconds, tzinfo=&#39;utc&#39;)
                arg = {
                    DAYS: arg.days,
                    HOURS: date.hour,
                    MINUTES: date.minute,
                    SECONDS: date.second,
                    MICROSECONDS: arg.microseconds
                }

            if is_str:
                values = re.findall(r&#39;\d+&#39;, arg)
                units = re.findall(r&#39;\D+&#39;, arg)
                if len(values) &gt; 1:
                    return None
                elif len(units) &gt; 1:
                    return None
                if len(values) == 1 and len(units) == 1:
                    arg = [values[0], units[0]]
                    is_str = False

            if is_str or not isinstance(arg, Iterable):
                if i == 0:
                    continue
                arg = [args[i - 1], args[i]]
                is_str = False

            if not is_str and isinstance(arg, Sequence):
                try:
                    val = float(arg[0])
                    unit = str(arg[1])
                    arg = {unit: val}
                except Exception:
                    continue

            if isinstance(arg, Mapping):
                for maybe_unit in arg:
                    unit = cls.parse_unit(maybe_unit)
                    if unit is None:
                        # Invalid unit
                        return None
                    if unit in t:
                        # Repeated values for one unit is dissalowed
                        return None
                    val = arg[maybe_unit]
                    if not isinstance(val, Number) or val &lt; 0:
                        # Only positive values supported
                        return None
                    t[unit] = int(val)

        t = util.filter_any(None, t)

        if len(t) != 1:
            # A calendar length can be only be made up of one component
            return None

        return t

    @classmethod
    def parse_unit(cls, maybe_unit):
        unit = None
        if maybe_unit in TIME_SYMBOLS:
            unit = TIME_UNIT_MAP[maybe_unit]
        else:
            maybe_unit = maybe_unit.lower()
            for valid_unit in TIME_UNITS_P_AND_S:
                if valid_unit.startswith(maybe_unit):
                    unit = valid_unit
                    break
            if unit not in TIME_UNITS:
                # Invalid unit
                unit = None
        return unit

    @classmethod
    def unit_symbol(cls, unit):
        assert unit in TIME_UNITS
        return TIME_SYMBOL_MAP[unit]

    @classmethod
    def singular_unit(cls, unit):
        assert unit in TIME_UNITS
        return SINGLUAR_UNIT_MAP[unit]

    @classmethod
    def plural_unit(cls, unit):
        assert unit in TIME_UNITS
        return unit

    @classmethod
    def _seconds_arithmetic(cls, a):
        # Check for numbers
        for x in a:
            if isinstance(x, Number):
                return True

    @classmethod
    def _to_seconds(cls, a):
        seconds: List[float] = []
        for x in a:
            if isinstance(x, Duration):
                seconds.append(x.total_seconds)
                warnings.warn(&#39;Implicitly converting calendar length into seconds&#39;, UserWarning)
            else:
                seconds.append(float(x))
        return seconds

    @classmethod
    def _get_cache(cls, *args, **kwargs):
        if len(args) == 1 and len(kwargs) == 0 and type(args[0]) == str:
            if args[0] in _str_parse_cache:
                return _str_parse_cache[args[0]]
        return None

    @classmethod
    def _set_cache(cls, r, *args, **kwargs):
        if len(args) == 1 and len(kwargs) == 0 and type(args[0]) == str:
            _str_parse_cache[args[0]] = r

    def __add__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] + secs[1]

    def __sub__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] - secs[1]

    def __mul__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] * secs[1]

    def __truediv__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] / secs[1]

    def __floordiv__(self, other):
        secs = type(self)._to_seconds([self, other])
        return secs[0] // secs[1]

    def __radd__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] + secs[1]

    def __rsub__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] - secs[1]

    def __rmul__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] * secs[1]

    def __rtruediv__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] / secs[1]

    def __rfloordiv__(self, other):
        secs = type(self)._to_seconds([other, self])
        return secs[0] // secs[1]

    def __neg__(self):
        return -self.total_seconds

    def __pos__(self):
        return self.total_seconds

    def __abs__(self):
        return self.total_seconds

    def __lt__(self, other):
        if isinstance(other, Number):
            return self.max_seconds &lt; other

        if type(self) != type(other):
            raise Exception(f&#39;Unable to compare with: {other}&#39;)
        if self.unit == other.unit:
            return self.degree &lt; other.degree
        else:
            return self.max_seconds &lt; other.min_seconds

    def __gt__(self, other):
        if isinstance(other, Number):
            return self.min_seconds &gt; other

        if type(self) != type(other):
            raise Exception(f&#39;Unable to compare with: {other}&#39;)
        if self.unit == other.unit:
            return self.degree &gt; other.degree
        else:
            return self.min_seconds &gt; other.max_seconds</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyduration.duration.Duration.units"><code class="name">var <span class="ident">units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyduration.duration.Duration.normalized_dict"><code class="name flex">
<span>def <span class="ident">normalized_dict</span></span>(<span>*args, **kwargs) ‑> Union[Dict[str, int], NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def normalized_dict(cls, *args, **kwargs) -&gt; Optional[Dict[str, int]]:
    args = util.flatten(args)
    split_args: List[Any] = []
    for arg in args:
        if isinstance(arg, str):
            split_args += arg.split(&#39; &#39;)
        else:
            split_args.append(arg)
    split_args.append(dict(kwargs))
    split_args = list(filter(None, split_args))
    args = split_args

    if len(args) == 1 and isinstance(args[0], Number):
        # Single number argument is assumed to be in seconds.
        seconds = args[0]
        if seconds &lt; 0:
            return None
        args[0] = timedelta(seconds=seconds)

    t: Dict[str, int] = {}

    for i in range(len(args)):
        arg = args[i]
        is_str = isinstance(arg, (str, bytes))
        if isinstance(arg, Duration):
            arg = arg.get_descriptor()

        if isinstance(arg, timedelta):
            # Normalize the time components as
            # much as possible.
            date = arrow.get(arg.seconds, tzinfo=&#39;utc&#39;)
            arg = {
                DAYS: arg.days,
                HOURS: date.hour,
                MINUTES: date.minute,
                SECONDS: date.second,
                MICROSECONDS: arg.microseconds
            }

        if is_str:
            values = re.findall(r&#39;\d+&#39;, arg)
            units = re.findall(r&#39;\D+&#39;, arg)
            if len(values) &gt; 1:
                return None
            elif len(units) &gt; 1:
                return None
            if len(values) == 1 and len(units) == 1:
                arg = [values[0], units[0]]
                is_str = False

        if is_str or not isinstance(arg, Iterable):
            if i == 0:
                continue
            arg = [args[i - 1], args[i]]
            is_str = False

        if not is_str and isinstance(arg, Sequence):
            try:
                val = float(arg[0])
                unit = str(arg[1])
                arg = {unit: val}
            except Exception:
                continue

        if isinstance(arg, Mapping):
            for maybe_unit in arg:
                unit = cls.parse_unit(maybe_unit)
                if unit is None:
                    # Invalid unit
                    return None
                if unit in t:
                    # Repeated values for one unit is dissalowed
                    return None
                val = arg[maybe_unit]
                if not isinstance(val, Number) or val &lt; 0:
                    # Only positive values supported
                    return None
                t[unit] = int(val)

    t = util.filter_any(None, t)

    if len(t) != 1:
        # A calendar length can be only be made up of one component
        return None

    return t</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, *args, **kwargs):
    cached = cls._get_cache(*args, **kwargs)
    if cached is not None:
        return cached

    if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], Duration):
        return args[0]
    else:
        r = Duration(*args, **kwargs)
        cls._set_cache(r, *args, **kwargs)
        return r</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.parse_many"><code class="name flex">
<span>def <span class="ident">parse_many</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_many(cls, a):
    return [cls.parse(x) for x in a]</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.parse_unit"><code class="name flex">
<span>def <span class="ident">parse_unit</span></span>(<span>maybe_unit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_unit(cls, maybe_unit):
    unit = None
    if maybe_unit in TIME_SYMBOLS:
        unit = TIME_UNIT_MAP[maybe_unit]
    else:
        maybe_unit = maybe_unit.lower()
        for valid_unit in TIME_UNITS_P_AND_S:
            if valid_unit.startswith(maybe_unit):
                unit = valid_unit
                break
        if unit not in TIME_UNITS:
            # Invalid unit
            unit = None
    return unit</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.plural_unit"><code class="name flex">
<span>def <span class="ident">plural_unit</span></span>(<span>unit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def plural_unit(cls, unit):
    assert unit in TIME_UNITS
    return unit</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.singular_unit"><code class="name flex">
<span>def <span class="ident">singular_unit</span></span>(<span>unit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def singular_unit(cls, unit):
    assert unit in TIME_UNITS
    return SINGLUAR_UNIT_MAP[unit]</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.unit_symbol"><code class="name flex">
<span>def <span class="ident">unit_symbol</span></span>(<span>unit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def unit_symbol(cls, unit):
    assert unit in TIME_UNITS
    return TIME_SYMBOL_MAP[unit]</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyduration.duration.Duration.ave_seconds"><code class="name">var <span class="ident">ave_seconds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ave_seconds(self):
    return self.degree * SECONDS_AVE[self.unit]</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.degree"><code class="name">var <span class="ident">degree</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def degree(self):
    return list(self._data.values())[0]</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.is_calendar_required"><code class="name">var <span class="ident">is_calendar_required</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_calendar_required(self):
    if self.unit in CALENDAR_UNITS:
        return True
    # If we are not uniformly spread out
    # in a parent interval which, requires
    # a calendar, then we also require a
    # calendar to be able to find the
    # correct strating date.
    return self.parent is not None and \
        self.parent.is_calendar_required and \
        not self.is_uniform</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.is_uniform"><code class="name">var <span class="ident">is_uniform</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_uniform(self):
    if self._is_uniform_special_case():
        return True
    if self.min_seconds != self.max_seconds:
        return False
    if self.parent is None:
        return True
    coef = self._seconds_coef()
    s = self.ave_seconds * coef
    min_s = self.parent.min_seconds * coef
    max_s = self.parent.max_seconds * coef
    return min_s % s == 0 and max_s % s == 0</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.max_seconds"><code class="name">var <span class="ident">max_seconds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_seconds(self):
    return self.degree * SECONDS_RANGES[self.unit][1]</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.min_seconds"><code class="name">var <span class="ident">min_seconds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_seconds(self):
    if self._min_seconds is None:
        s = self.degree * SECONDS_RANGES[self.unit][0]
        if self.parent is None or self.degree == 1 or self._is_uniform_special_case():
            return s
        # The last interval may be smaller
        coef = self._seconds_coef()
        s *= coef
        parent_s = self.parent.min_seconds * coef
        last_s = parent_s % s
        if last_s == 0:
            # Uniform interval
            last_s = s
        self._min_seconds = last_s / coef
    return self._min_seconds</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Returns the parent calendar length, which clamps
this calendar length's intervals its intervals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#34;&#34;&#34;
    Returns the parent calendar length, which clamps
    this calendar length&#39;s intervals its intervals.
    &#34;&#34;&#34;
    if self._parent is None:
        if self.unit not in PARENTS:
            return None
        parent_unit = PARENTS[self.unit]
        self._parent = Duration({parent_unit: 1})
    return self._parent</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.symbol"><code class="name">var <span class="ident">symbol</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def symbol(self):
    return type(self).unit_symbol(self.unit)</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.total_seconds"><code class="name">var <span class="ident">total_seconds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def total_seconds(self):
    if not self.is_uniform:
        raise Exception(f&#39;Cannot convert calendar length {self} to uniform seconds&#39;)
    return self.min_seconds</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.unit"><code class="name">var <span class="ident">unit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit(self):
    return list(self._data.keys())[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyduration.duration.Duration.aggregate"><code class="name flex">
<span>def <span class="ident">aggregate</span></span>(<span>self, degree: int) ‑> <a title="pyduration.duration.Duration" href="#pyduration.duration.Duration">Duration</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a calendar length multiplied by the specified <code>degree</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aggregate(self, degree: int) -&gt; &#39;Duration&#39;:
    &#34;&#34;&#34;
    Returns a calendar length multiplied by the specified `degree`.
    &#34;&#34;&#34;
    return self.with_degree(self.degree * degree)</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.ceil"><code class="name flex">
<span>def <span class="ident">ceil</span></span>(<span>self, date) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the boundary at or after the specified <code>date</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ceil(self, date) -&gt; float:
    &#34;&#34;&#34;
    Returns the boundary at or after the specified `date`.
    &#34;&#34;&#34;
    return self.span_date(date, start_open=True).end</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self, interval, start_open=False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of intervals in the specified interval.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self, interval, start_open=False) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of intervals in the specified interval.
    &#34;&#34;&#34;
    interval = Interval.parse(interval, default_inf=True)
    if interval.is_empty:
        return 0
    if not interval.is_finite:
        raise Exception(&#39;Cannot count intervals on infinite interval&#39;)
    interval = self.span_interval(interval, start_open=start_open)

    if not self.is_uniform:
        # Walk spans
        # TODO: this can be optimised to avoid walking
        count = 0
        for _ in self.iterate(interval):
            count += 1
        return count
    else:
        # Use seconds
        return int(math.ceil(interval.length / self.ave_seconds))</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.equals"><code class="name flex">
<span>def <span class="ident">equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equals(self, other):
    return type(self) == type(other) and \
        self._data == other._data</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.floor"><code class="name flex">
<span>def <span class="ident">floor</span></span>(<span>self, date) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the boundary at or before the specified <code>date</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def floor(self, date) -&gt; float:
    &#34;&#34;&#34;
    Returns the boundary at or before the specified `date`.
    &#34;&#34;&#34;
    return self.span_date(date, start_open=False).start</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.get_descriptor"><code class="name flex">
<span>def <span class="ident">get_descriptor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_descriptor(self):
    return dict(self._data)</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.iterate"><code class="name flex">
<span>def <span class="ident">iterate</span></span>(<span>self, interval, size=1, backward=False, start_open=False) ‑> Iterator[Union[intervalpy.interval.Interval, NoneType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterates time-spans inside a interval.
Does not trim timespans inside the interval.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterate(self, interval, size=1, backward=False, start_open=False) -&gt; Iterator[Optional[Interval]]:
    &#34;&#34;&#34;
    Iterates time-spans inside a interval.
    Does not trim timespans inside the interval.
    &#34;&#34;&#34;
    interval = Interval.parse(interval, default_inf=True)
    if interval.is_empty:
        return iter([])
    start = interval.start if not backward else interval.end
    if math.isinf(start):
        raise ValueError(&#39;Cannot iterate intervals from infinity&#39;)
    if size &lt; 1:
        raise ValueError(&#39;Size must ba a positive integer&#39;)

    if self.is_uniform:
        interval_span = self.span_interval(interval, start_open=start_open)
        start = interval_span.start if not backward else interval_span.end
        count = math.ceil(self.count(interval_span, start_open=start_open) / size)
        step = size * self.ave_seconds
        if backward:
            step = -step
        i = 0

        def next_uniform_span():
            nonlocal start, step, i, count

            if i == count:
                return None
            a = start + i * step
            b = a + step
            i += 1
            return Interval(min(a, b), max(a, b), start_open=start_open, end_open=not start_open)

        return iter(next_uniform_span, None)

    walker = self.walk(start, size=size, backward=backward, start_open=start_open)

    def next_span_in_interval():
        nonlocal start

        while True:
            span = next(walker)
            if span is None or span.is_empty:
                return None
            elif span.intersects(interval):
                return span
            elif span.contains(start):
                # Keep looking for interval
                continue
            else:
                # Went outside interval
                return None

        return None

    return iter(next_span_in_interval, None)</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self, date) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the next boundary after the specified <code>date</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self, date) -&gt; float:
    &#34;&#34;&#34;
    Returns the next boundary after the specified `date`.
    &#34;&#34;&#34;
    return self.span_date(date, start_open=False).end</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>self, interval, start=0, end=0, start_open=False) ‑> intervalpy.interval.Interval</span>
</code></dt>
<dd>
<div class="desc"><p>Appends calendar lengths to the start and end of a interval.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad(self, interval, start=0, end=0, start_open=False) -&gt; Interval:
    &#34;&#34;&#34;
    Appends calendar lengths to the start and end of a interval.
    &#34;&#34;&#34;
    interval = self.span_interval(interval, start_open=start_open)
    if interval.is_empty:
        return Interval.empty()

    l = interval.start
    if not interval.is_negative_infinite:
        l = self.step(l, count=start, backward=True)

    h = interval.end
    if not interval.is_positive_infinite:
        h = self.step(h, count=end)

    return Interval(l, h, start_open=start_open, end_open=not start_open)</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.previous"><code class="name flex">
<span>def <span class="ident">previous</span></span>(<span>self, date) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the previous boundary before the specified <code>date</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previous(self, date) -&gt; float:
    &#34;&#34;&#34;
    Returns the previous boundary before the specified `date`.
    &#34;&#34;&#34;
    return self.span_date(date, start_open=True).start</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.round"><code class="name flex">
<span>def <span class="ident">round</span></span>(<span>self, date) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the closest boundary to the specified <code>date</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round(self, date) -&gt; float:
    &#34;&#34;&#34;
    Returns the closest boundary to the specified `date`.
    &#34;&#34;&#34;
    ceil = self.ceil(date)
    floor = self.floor(date)
    if ceil - date &lt;= date - floor:
        return ceil
    else:
        return floor</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.set_descriptor"><code class="name flex">
<span>def <span class="ident">set_descriptor</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_descriptor(self, data):
    ndata = type(self).normalized_dict(data)
    if ndata is None:
        raise Exception(f&#39;Invalid calendar length data: {data}&#39;)
    self._data = ndata</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.span"><code class="name flex">
<span>def <span class="ident">span</span></span>(<span>self, x, start_open=False) ‑> intervalpy.interval.Interval</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the time interval which contains the specified single date or interval.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def span(self, x, start_open=False) -&gt; Interval:
    &#34;&#34;&#34;
    Returns the time interval which contains the specified single date or interval.
    &#34;&#34;&#34;
    if isinstance(x, Number):
        return self.span_date(x, start_open=start_open)
    else:
        return self.span_interval(x, start_open=start_open)</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.span_date"><code class="name flex">
<span>def <span class="ident">span_date</span></span>(<span>self, date, start_open=False) ‑> intervalpy.interval.Interval</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the time interval which contains the specified <code>date</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def span_date(self, date, start_open=False) -&gt; Interval:
    &#34;&#34;&#34;
    Returns the time interval which contains the specified `date`.
    &#34;&#34;&#34;
    if self.is_calendar_required:
        return self._calendar_span(date, start_open=start_open)
    else:
        return self._non_calendar_span(date, start_open=start_open)</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.span_interval"><code class="name flex">
<span>def <span class="ident">span_interval</span></span>(<span>self, interval, start_open=False) ‑> intervalpy.interval.Interval</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the time interval which fully contains the specified interval.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def span_interval(self, interval, start_open=False) -&gt; Interval:
    &#34;&#34;&#34;
    Returns the time interval which fully contains the specified interval.
    &#34;&#34;&#34;
    interval = Interval.parse(interval, default_inf=True)
    if interval.is_empty:
        return Interval.empty()
    elif interval.start == interval.end:
        return self.span_date(interval.start, start_open=start_open)

    end_open = not start_open

    if interval.is_negative_infinite:
        start = -math.inf
    else:
        # Move outward if interval is closed but should be open
        o = not interval.start_open and start_open
        span = self.span_date(interval.start, start_open=o)
        start = span.start

    if interval.is_positive_infinite:
        end = math.inf
    else:
        # Move outward if interval is closed but should be open
        o = not interval.end_open and end_open
        span = self.span_date(interval.end, start_open=not o)
        end = span.end

    return Interval(start, end, start_open=start_open, end_open=not start_open)</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, date, count=1, backward=False) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the <code>count</code>th boundary after or before the specified <code>date</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, date, count=1, backward=False) -&gt; float:
    &#34;&#34;&#34;
    Returns the `count`th boundary after or before the specified `date`.
    &#34;&#34;&#34;
    date = self._normalized_date(date)
    if count == 0:
        return date
    if count &lt; 0:
        backward = not backward
        count = -count
    count = int(count)
    rounder = self.ceil if not backward else self.floor
    ndate = rounder(date)
    if ndate != date:
        count -= 1

    if count &gt; 1 and self.is_uniform:
        # Use seconds
        if backward:
            count = -count
        seconds = self.ave_seconds
        return ndate + seconds * count
    else:
        # Iterate
        step = self.next if not backward else self.previous
        for _ in range(count):
            ndate = step(ndate)
        return ndate</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.to_str"><code class="name flex">
<span>def <span class="ident">to_str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_str(self):
    return f&#39;{self.degree}{self.symbol}&#39;</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.walk"><code class="name flex">
<span>def <span class="ident">walk</span></span>(<span>self, start, limit: Union[numbers.Number, NoneType] = None, size=1, backward=False, start_open=False) ‑> Iterator[Union[intervalpy.interval.Interval, NoneType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterates time-spans.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk(
    self,
    start,
    limit: Optional[Number] = None,
    size=1,
    backward=False,
    start_open=False
) -&gt; Iterator[Optional[Interval]]:
    &#34;&#34;&#34;
    Iterates time-spans.
    &#34;&#34;&#34;
    if limit is not None:
        if limit == 0:
            return iter([])
        if limit &lt; 0:
            limit = -limit
            backward = not backward
    span = self.span_date(start, start_open=start_open)
    if backward:
        x1 = span.end
    else:
        x1 = span.start
    count = 0

    def next_span():
        nonlocal x1, count
        if limit is not None and count &gt;= limit:
            return None
        count += 1
        x0 = x1
        x1 = self.step(x0, count=size, backward=backward)
        span = Interval(min(x0, x1), max(x0, x1), start_open=start_open, end_open=not start_open)
        return span

    return iter(next_span, None)</code></pre>
</details>
</dd>
<dt id="pyduration.duration.Duration.with_degree"><code class="name flex">
<span>def <span class="ident">with_degree</span></span>(<span>self, degree: int) ‑> <a title="pyduration.duration.Duration" href="#pyduration.duration.Duration">Duration</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a calendar length with specified <code>degree</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_degree(self, degree: int) -&gt; &#39;Duration&#39;:
    &#34;&#34;&#34;
    Returns a calendar length with specified `degree`.
    &#34;&#34;&#34;
    assert degree &gt; 0
    if degree == self.degree:
        return self
    d = self.get_descriptor()
    d = {k: degree for k, v in d.items()}
    return Duration(d)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyduration" href="index.html">pyduration</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyduration.duration.Duration" href="#pyduration.duration.Duration">Duration</a></code></h4>
<ul class="">
<li><code><a title="pyduration.duration.Duration.aggregate" href="#pyduration.duration.Duration.aggregate">aggregate</a></code></li>
<li><code><a title="pyduration.duration.Duration.ave_seconds" href="#pyduration.duration.Duration.ave_seconds">ave_seconds</a></code></li>
<li><code><a title="pyduration.duration.Duration.ceil" href="#pyduration.duration.Duration.ceil">ceil</a></code></li>
<li><code><a title="pyduration.duration.Duration.count" href="#pyduration.duration.Duration.count">count</a></code></li>
<li><code><a title="pyduration.duration.Duration.degree" href="#pyduration.duration.Duration.degree">degree</a></code></li>
<li><code><a title="pyduration.duration.Duration.equals" href="#pyduration.duration.Duration.equals">equals</a></code></li>
<li><code><a title="pyduration.duration.Duration.floor" href="#pyduration.duration.Duration.floor">floor</a></code></li>
<li><code><a title="pyduration.duration.Duration.get_descriptor" href="#pyduration.duration.Duration.get_descriptor">get_descriptor</a></code></li>
<li><code><a title="pyduration.duration.Duration.is_calendar_required" href="#pyduration.duration.Duration.is_calendar_required">is_calendar_required</a></code></li>
<li><code><a title="pyduration.duration.Duration.is_uniform" href="#pyduration.duration.Duration.is_uniform">is_uniform</a></code></li>
<li><code><a title="pyduration.duration.Duration.iterate" href="#pyduration.duration.Duration.iterate">iterate</a></code></li>
<li><code><a title="pyduration.duration.Duration.max_seconds" href="#pyduration.duration.Duration.max_seconds">max_seconds</a></code></li>
<li><code><a title="pyduration.duration.Duration.min_seconds" href="#pyduration.duration.Duration.min_seconds">min_seconds</a></code></li>
<li><code><a title="pyduration.duration.Duration.next" href="#pyduration.duration.Duration.next">next</a></code></li>
<li><code><a title="pyduration.duration.Duration.normalized_dict" href="#pyduration.duration.Duration.normalized_dict">normalized_dict</a></code></li>
<li><code><a title="pyduration.duration.Duration.pad" href="#pyduration.duration.Duration.pad">pad</a></code></li>
<li><code><a title="pyduration.duration.Duration.parent" href="#pyduration.duration.Duration.parent">parent</a></code></li>
<li><code><a title="pyduration.duration.Duration.parse" href="#pyduration.duration.Duration.parse">parse</a></code></li>
<li><code><a title="pyduration.duration.Duration.parse_many" href="#pyduration.duration.Duration.parse_many">parse_many</a></code></li>
<li><code><a title="pyduration.duration.Duration.parse_unit" href="#pyduration.duration.Duration.parse_unit">parse_unit</a></code></li>
<li><code><a title="pyduration.duration.Duration.plural_unit" href="#pyduration.duration.Duration.plural_unit">plural_unit</a></code></li>
<li><code><a title="pyduration.duration.Duration.previous" href="#pyduration.duration.Duration.previous">previous</a></code></li>
<li><code><a title="pyduration.duration.Duration.round" href="#pyduration.duration.Duration.round">round</a></code></li>
<li><code><a title="pyduration.duration.Duration.set_descriptor" href="#pyduration.duration.Duration.set_descriptor">set_descriptor</a></code></li>
<li><code><a title="pyduration.duration.Duration.singular_unit" href="#pyduration.duration.Duration.singular_unit">singular_unit</a></code></li>
<li><code><a title="pyduration.duration.Duration.span" href="#pyduration.duration.Duration.span">span</a></code></li>
<li><code><a title="pyduration.duration.Duration.span_date" href="#pyduration.duration.Duration.span_date">span_date</a></code></li>
<li><code><a title="pyduration.duration.Duration.span_interval" href="#pyduration.duration.Duration.span_interval">span_interval</a></code></li>
<li><code><a title="pyduration.duration.Duration.step" href="#pyduration.duration.Duration.step">step</a></code></li>
<li><code><a title="pyduration.duration.Duration.symbol" href="#pyduration.duration.Duration.symbol">symbol</a></code></li>
<li><code><a title="pyduration.duration.Duration.to_str" href="#pyduration.duration.Duration.to_str">to_str</a></code></li>
<li><code><a title="pyduration.duration.Duration.total_seconds" href="#pyduration.duration.Duration.total_seconds">total_seconds</a></code></li>
<li><code><a title="pyduration.duration.Duration.unit" href="#pyduration.duration.Duration.unit">unit</a></code></li>
<li><code><a title="pyduration.duration.Duration.unit_symbol" href="#pyduration.duration.Duration.unit_symbol">unit_symbol</a></code></li>
<li><code><a title="pyduration.duration.Duration.units" href="#pyduration.duration.Duration.units">units</a></code></li>
<li><code><a title="pyduration.duration.Duration.walk" href="#pyduration.duration.Duration.walk">walk</a></code></li>
<li><code><a title="pyduration.duration.Duration.with_degree" href="#pyduration.duration.Duration.with_degree">with_degree</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>